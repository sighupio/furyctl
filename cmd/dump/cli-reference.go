// Copyright (c) 2017-present SIGHUP s.r.l All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package dump

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/sighupio/furyctl/internal/analytics"
	"github.com/sighupio/furyctl/internal/app"
	cobrax "github.com/sighupio/furyctl/internal/x/cobra"
	iox "github.com/sighupio/furyctl/internal/x/io"
)

type CliReferenceCmdFlags struct {
	NoOverwrite bool
	Workdir     string
}

var (
	ErrTooManyPosArgs     = errors.New("exactly one output folder path argument is allowed")
	ErrOutputFolderExists = errors.New("output folder already exists. Use --no-overwrite=false to overwrite it")
)

func NewDumpCLIReferenceCmd() *cobra.Command {
	var cmdEvent analytics.Event

	dumpCLIReferenceCmd := &cobra.Command{
		Use:     "cli-reference [folder]",
		Short:   "Exports the CLI reference in markdown format into a specified folder in the working directory",
		Long:    "Exports the CLI reference in markdown format into a specified folder in the working directory. The folder will be created if it does not exist.",
		Example: `furyctl dump cli-reference ./docs/cli-reference`,
		PreRun: func(cmd *cobra.Command, _ []string) {
			cmdEvent = analytics.NewCommandEvent(cobrax.GetFullname(cmd))

			if err := viper.BindPFlags(cmd.Flags()); err != nil {
				logrus.Fatalf("error while binding flags: %v", err)
			}
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctn := app.GetContainerInstance()

			tracker := ctn.Tracker()
			tracker.Flush()

			flags := getDumpCliReferenceCmdFlags()

			outputFolder := flags.Workdir

			if len(args) > 1 {
				return ErrTooManyPosArgs
			} else if len(args) == 1 {
				outputFolder = filepath.Join(outputFolder, args[0])
			}

			if flags.NoOverwrite {
				if _, err := os.Stat(outputFolder); err == nil {
					return ErrOutputFolderExists
				}
			}

			if err := os.MkdirAll(outputFolder, iox.FullPermAccess); err != nil {
				return ErrOutputFolderExists
			}
			outputPath := filepath.Join(outputFolder, "index.md")
			mainFile, err := os.Create(outputPath)
			if err != nil {
				return fmt.Errorf("failed to generate CLI reference for main command: %w", err)
			}
			defer mainFile.Close()

			dummyFilePrepender := func(_ string) string {
				return ""
			}

			linkHandlerRoot := func(name string) string {
				if name == "furyctl.md" {
					return "index.md"
				}

				for _, command := range cmd.Root().Commands() {
					basename := strings.ReplaceAll(command.CommandPath(), " ", "_") + ".md"
					if basename == name {
						return filepath.Join(command.Name(), "index.md")
					}
				}

				return name
			}

			linkHandler := func(name string) string {
				if name == "furyctl.md" {
					return "../index.md"
				}

				for _, command := range cmd.Root().Commands() {
					basename := strings.ReplaceAll(command.CommandPath(), " ", "_") + ".md"
					if basename == name {
						return fmt.Sprintf("../%s/index.md", command.Name())
					}
				}

				return name
			}

			cmd.Root().DisableAutoGenTag = true

			if err := genMarkdownCustom(cmd.Root(), mainFile, linkHandlerRoot); err != nil {
				return fmt.Errorf("failed to generate CLI reference: %w", err)
			}
			for _, command := range cmd.Root().Commands() {
				outputPath := filepath.Join(outputFolder, command.Name())
				if err := os.MkdirAll(outputPath, iox.FullPermAccess); err != nil {
					return fmt.Errorf("failed to create output folder: %w", err)
				}
				err := genMarkdownTreeCustom(command, outputPath, dummyFilePrepender, linkHandler)
				if err != nil {
					return fmt.Errorf("failed to generate CLI reference for command %s: %w", command.Name(), err)
				}
				if err := os.Rename(fmt.Sprintf("%s/furyctl_%s.md", outputPath, command.Name()), filepath.Join(outputPath, "index.md")); err != nil {
					return fmt.Errorf("failed to rename CLI reference file for command %s: %w", command.Name(), err)
				}
				// We need to this, because the markdown file generated by cobra has a code block that is not wrapped in triple backticks.
				if command.Name() == "completion" {
					if err := escapeCodeBlock(filepath.Join(outputPath, "index.md")); err != nil {
						return fmt.Errorf("failed to escape code block in CLI reference for command %s: %w", command.Name(), err)
					}
				}
			}

			logrus.Infof("Markdown CLI reference successfully exported to %s", outputFolder)

			cmdEvent.AddSuccessMessage("CIL Reference generated successfully")
			tracker.Track(cmdEvent)

			return nil
		},
	}

	dumpCLIReferenceCmd.Flags().Bool("no-overwrite", true, "Do not overwrite existing files. Will exit if the output folder already exists. WARNING: setting this to false will delete the folder and its content.")
	dumpCLIReferenceCmd.Flags().StringP("workdir", "w", "", "Working directory to use for the output folder. Default is the current working directory")

	return dumpCLIReferenceCmd
}

func getDumpCliReferenceCmdFlags() CliReferenceCmdFlags {
	return CliReferenceCmdFlags{
		NoOverwrite: viper.GetBool("no-overwrite"),
		Workdir:     viper.GetString("workdir"),
	}
}

func escapeCodeBlock(path string) error {
	// Escape code blocks in the file surrounding them with triple backticks.
	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %w", path, err)
	}

	reUnix := regexp.MustCompile(`(.+)\$ (.+)`)
	rePS := regexp.MustCompile(`(.+)PS> (.+)`)
	escapedContent := string(content)
	escapedContent = reUnix.ReplaceAllString(escapedContent, "${1}```shell\n${1}$$ ${2}\n${1}```")
	escapedContent = rePS.ReplaceAllString(escapedContent, "${1}```powershell\n${1}PS> ${2}\n${1}```")
	reFencedNewLineFix := regexp.MustCompile(":\\n(.+)```")
	escapedContent = reFencedNewLineFix.ReplaceAllString(escapedContent, ":\n\n${1}```")

	fileStat, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("failed to stat file %s: %w", path, err)
	}

	if err := os.WriteFile(path, []byte(escapedContent), fileStat.Mode().Perm()); err != nil {
		return fmt.Errorf("failed to write file %s: %w", path, err)
	}

	return nil
}
